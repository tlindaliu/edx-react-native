# -*- coding: utf-8 -*-
#

# Imports ###########################################################

import json
import webob
import copy
import urllib

from xblock.core import XBlock
from xblock.fields import Scope, String, Dict, Float, Boolean
from xblock.fragment import Fragment

from .utils import render_template, load_resource
from .default_data import DEFAULT_DATA


# Classes ###########################################################

class DragAndDropBlock(XBlock):
    """
    XBlock providing a Drag and Drop question
    """
    display_name = String(
        display_name="Title",
        help="The title of the Drag and Drop that is displayed to the user",
        scope=Scope.settings,
        default="Drag and Drop"
    )

    question_text = String(
        display_name="Question text",
        help="The question text that is displayed to the user",
        scope=Scope.settings,
        default=""
    )

    weight = Float(
        display_name="Weight",
        help="This is the maximum score that the user receives when he/she successfully completes the problem",
        scope=Scope.settings,
        default=1
    )

    data = Dict(
        display_name="Drag and Drop",
        help="JSON spec as generated by the builder",
        scope=Scope.content,
        default=DEFAULT_DATA
    )

    item_state = Dict(
        help="How the student has interacted with the problem",
        scope=Scope.user_state,
        default={}
    )

    completed = Boolean(
        help="The student has completed the problem at least once",
        scope=Scope.user_state,
        default=False
    )

    has_score = True

    def react_view(self, context):
        """
        Student view using React.js
        """
        fragment = Fragment()
        fragment.add_content(render_template('/templates/index.html'))
        js_urls = (
            'public/js/drag_and_drop_react.js',
            'public/js/bundle.js'
            # the order of these js files is important so that functions are defined by the time they're called
        )

        for js_url in js_urls:
            fragment.add_javascript_url(self.runtime.local_resource_url(self, js_url))

        fragment.initialize_js('DragAndDropReact')
        return fragment

    def student_view(self, context):
        """
        Player view, displayed to the student
        """
        fragment = Fragment()
        fragment.add_content(render_template('/templates/html/drag_and_drop.html'))
        css_urls = (
            'public/css/vendor/jquery-ui-1.10.4.custom.min.css',
            'public/css/drag_and_drop.css'
        )
        js_urls = (
            'public/js/vendor/jquery-ui-1.10.4.custom.min.js',
            'public/js/vendor/jquery-ui-touch-punch-0.2.3.min.js',  # Makes it work on touch devices
            'public/js/vendor/virtual-dom-1.3.0.min.js',
            'public/js/drag_and_drop.js',
            'public/js/view.js',
        )

        for css_url in css_urls:
            fragment.add_css_url(self.runtime.local_resource_url(self, css_url))
        for js_url in js_urls:
            fragment.add_javascript_url(self.runtime.local_resource_url(self, js_url))

        fragment.initialize_js('DragAndDropBlock')

        return fragment

    def studio_view(self, context):
        """
        Editing view in Studio
        """

        js_templates = load_resource('/templates/html/js_templates.html')
        context = {
            'js_templates': js_templates,
            'self': self,
            'data': urllib.quote(json.dumps(self.data)),
        }

        fragment = Fragment()
        fragment.add_content(render_template('/templates/html/drag_and_drop_edit.html', context))

        css_urls = (
            'public/css/vendor/jquery-ui-1.10.4.custom.min.css',
            'public/css/drag_and_drop_edit.css'
        )
        js_urls = (
            'public/js/vendor/jquery-ui-1.10.4.custom.min.js',
            'public/js/vendor/jquery.html5-placeholder-shim.js',
            'public/js/vendor/handlebars-v1.1.2.js',
            'public/js/drag_and_drop_edit.js',
        )
        for css_url in css_urls:
            fragment.add_css_url(self.runtime.local_resource_url(self, css_url))
        for js_url in js_urls:
            fragment.add_javascript_url(self.runtime.local_resource_url(self, js_url))

        fragment.initialize_js('DragAndDropEditBlock')

        return fragment

    @XBlock.json_handler
    def studio_submit(self, submissions, suffix=''):
        self.display_name = submissions['display_name']
        self.question_text = submissions['question_text']
        self.weight = float(submissions['weight'])
        self.data = submissions['data']

        return {
            'result': 'success',
        }

    @XBlock.handler
    def get_data(self, request, suffix=''):
        data = self._get_data()
        return webob.response.Response(body=json.dumps(data))

    @XBlock.json_handler
    def do_attempt(self, attempt, suffix=''):
        item = next(i for i in self.data['items'] if i['id'] == attempt['val'])

        state = None
        feedback = item['feedback']['incorrect']
        final_feedback = None
        is_correct = False
        is_correct_location = False

        if 'input' in attempt:
            state = self._get_item_state().get(str(item['id']))
            if state:
                state['input'] = attempt['input']
                is_correct_location = True
                if self._is_correct_input(item, attempt['input']):
                    is_correct = True
                    feedback = item['feedback']['correct']
                else:
                    is_correct = False
        elif item['zone'] == attempt['zone']:
            is_correct_location = True
            if 'inputOptions' in item:
                # Input value will have to be provided for the item.
                # It is not (yet) correct and no feedback should be shown yet.
                is_correct = False
                feedback = None
            else:
                # If this item has no input value set, we are done with it.
                is_correct = True
                feedback = item['feedback']['correct']
            state = {
                'top': attempt['top'],
                'left': attempt['left'],
                'absolute': True  # flag for backwards compatibility (values used to be relative)
            }

        if state:
            self.item_state[str(item['id'])] = state

        if self._is_finished():
            final_feedback = self.data['feedback']['finish']

        # don't publish the grade if the student has already completed the exercise
        if not self.completed:
            if self._is_finished():
                self.completed = True
            try:
                self.runtime.publish(self, 'grade', {
                    'value': self._get_grade(),
                    'max_value': self.weight,
                })
            except NotImplementedError:
                # Note, this publish method is unimplemented in Studio runtimes,
                # so we have to figure that we're running in Studio for now
                pass

        self.runtime.publish(self, 'xblock.drag-and-drop-v2.item.dropped', {
            'user_id': self.scope_ids.user_id,
            'component_id': self._get_unique_id(),
            'item_id': item['id'],
            'location': attempt.get('zone'),
            'input': attempt.get('input'),
            'is_correct_location': is_correct_location,
            'is_correct': is_correct,
        })

        return {
            'correct': is_correct,
            'correct_location': is_correct_location,
            'finished': self._is_finished(),
            'final_feedback': final_feedback,
            'feedback': feedback
        }

    @XBlock.json_handler
    def reset(self, data, suffix=''):
        self.item_state = {}
        return self._get_data()

    def _get_data(self):
        data = copy.deepcopy(self.data)

        for item in data['items']:
            # Strip answers
            del item['feedback']
            del item['zone']
            item['inputOptions'] = 'inputOptions' in item

        if not self._is_finished():
            del data['feedback']['finish']

        item_state = self._get_item_state()
        for item_id, item in item_state.iteritems():
            definition = next(i for i in self.data['items'] if str(i['id']) == item_id)
            item['correct_input'] = self._is_correct_input(definition, item.get('input'))

        data['state'] = {
            'items': item_state,
            'finished': self._is_finished()
        }

        data['title'] = self.display_name
        data['question_text'] = self.question_text

        return data

    def _get_item_state(self):
        """
        Returns the user item state.
        Converts to a dict if data is stored in legacy tuple form.
        """
        state = {}

        for item_id, item in self.item_state.iteritems():
            if isinstance(item, dict):
                state[item_id] = item
            else:
                state[item_id] = {'top': item[0], 'left': item[1]}

        return state

    def _get_grade(self):
        """
        Returns the student's grade for this block.
        """
        correct_count = 0
        total_count = 0
        item_state = self._get_item_state()

        for item in self.data['items']:
            if item['zone'] != 'none':
                total_count += 1
                item_id = str(item['id'])
                if item_id in item_state:
                    if self._is_correct_input(item, item_state[item_id].get('input')):
                        correct_count += 1

        return correct_count / float(total_count) * self.weight

    def _is_finished(self):
        """
        All items are at their correct place and a value has been
        submitted for each item that expects a value.
        """
        completed_count = 0
        total_count = 0
        item_state = self._get_item_state()
        for item in self.data['items']:
            if item['zone'] != 'none':
                total_count += 1
                item_id = str(item['id'])
                if item_id in item_state:
                    if 'inputOptions' in item:
                        if 'input' in item_state[item_id]:
                            completed_count += 1
                    else:
                        completed_count += 1

        return completed_count == total_count

    @XBlock.json_handler
    def publish_event(self, data, suffix=''):
        try:
            event_type = data.pop('event_type')
        except KeyError:
            return {'result': 'error', 'message': 'Missing event_type in JSON data'}

        data['user_id'] = self.scope_ids.user_id
        data['component_id'] = self._get_unique_id()

        self.runtime.publish(self, event_type, data)
        return {'result': 'success'}

    def _get_unique_id(self):
        try:
            unique_id = self.location.name  # pylint: disable=no-member
        except AttributeError:
            # workaround for xblock workbench
            unique_id = self.parent and self.parent.replace('.',  '-')
        return unique_id

    @staticmethod
    def _is_correct_input(item, val):
        """
        Is submitted numerical value within the tolerated margin for this item.
        """
        input_options = item.get('inputOptions')

        if input_options:
            try:
                submitted_value = float(val)
            except (ValueError, TypeError):
                return False
            else:
                expected_value = input_options['value']
                margin = input_options['margin']
                return abs(submitted_value - expected_value) <= margin
        else:
            return True

    @staticmethod
    def workbench_scenarios():
        """
        A canned scenario for display in the workbench.
        """
        return [("Drag-and-drop-v2 scenario", "<vertical_demo><drag-and-drop-v2/></vertical_demo>"), ("Drag-and-drop-v2 React", "<drag-and-drop-v2/>")]
